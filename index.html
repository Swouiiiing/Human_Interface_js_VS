<!DOCTYPE html>
<html lang="en">
<
<head>
    <title>Try Again</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=yes, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            position: absolute;
            top: 0px;
            margin: 0px 0px 0px 0px;
            z-index: 3;
        }

        #monitor {
            margin: 0px 0px 0px 0px;
            position: absolute;
            top: 0px;
            left: 0px;
            float: left;
            visibility: hidden;
            z-index: 1;
        }

        #videoImage {
            margin: 0px 0px 0px 0px;
            position: absolute;
            top: 0px;
            left: 0px;
            float: left;
            visibility: hidden;
            z-index: 5;
        }

        #File {
            position: absolute;
            top: 0px;
            left: 800px;
            z-index: 7;
        }
    </style>
</head>

<p id="errorMessage"></p>
<body>
    <video id="monitor" autoplay width="500" height="500"></video>
    <canvas id="videoImage" width="500" height="500"></canvas>

    <form>
        <input type="file" id="File" onload="files_loaded(this.files)" multiple>
    </form>
    <div>
        <script>
            navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
            window.URL = window.URL || window.webkitURL;
            var camvideo = document.getElementById('monitor');
            if (!navigator.getUserMedia) {
                document.getElementById('errorMessage').innerHTML =
                    'Sorry. <code>navigator.getUserMedia()</code> is not available.';
            } else {
                navigator.getUserMedia({ video: true }, gotStream, noStream);
            }
            function gotStream(stream) {
                if (window.URL)
                { camvideo.src = window.URL.createObjectURL(stream); }
                else // Opera
                { camvideo.src = stream; }
                camvideo.onerror = function (e)
                { stream.stop(); };
                stream.onended = noStream;
            }
            function noStream(e) {
                var msg = 'No camera available.';
                if (e.code == 1)
                { msg = 'User denied access to use camera.'; }
                document.getElementById('errorMessage').textContent = msg;
            }
        </script>
        <script src="build/three.js"></script>
        <script src="examples/js/controls/OrbitControls.js"></script>
        <script src="examples/js/libs/stats.min.js"></script>
        <script src="examples/js/libs/dat.gui.min.js"></script>
        <script src="examples/js/loaders/STLLoader.js"></script>
        <script src="examples/js/renderers/Projector.js"></script>
        <script src="examples/js/Detector.js"></script>
        <script src="examples/js/libs/stats.min.js"></script>
        <script src="examples/js/THREEx.KeyboardState.js"></script>

        <script>
            var camera, scene, renderer;     //  Creation of the scene
            var video, videoImage, videoImageContext, videoTexture, backgroundtexture, backgroundMesh, backgroundScene, backgroundCamera, stats, controls, mesh;  //creation of background
            var mouse, raycaster; //selection by raycasting
            //Variable for hide objects of the gui
            var group;
            var hide_obj = [];
            var fileElem;
            var meshes = [];
            var gui;
            var comeOn = [];
            var variable = [];
            var hiders = [];
            var petit_a_petit = [];
            //var h;
            
            //initialisation and looping the scene
            init();
            animate();
            function init() {
                camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.01, 800);
                camera.position.set(-20, 10, 50);
                camera.lookAt(new THREE.Vector3(0, 0, 0, ));
                scene = new THREE.Scene();
                //Lights
                var light = new THREE.HemisphereLight(0xffffbb, 0x080820, 1);
                scene.add(light);
                scene.add(new THREE.AmbientLight(0x505050));
                // Video
                video = document.getElementById('monitor');
                videoImage = document.getElementById('videoImage');
                videoImageContext = videoImage.getContext('2d');
                // Background color if no video present
                videoImageContext.fillStyle = '#000000';
                videoImageContext.fillRect(0, 0, videoImage.innerWidth, videoImage.innerHeight);
                videoTexture = new THREE.Texture(videoImage);
                videoTexture.minFilter = THREE.LinearFilter;
                videoTexture.magFilter = THREE.LinearFilter;
                var movieMaterial = new THREE.MeshBasicMaterial({ map: videoTexture, overdraw: true, side: THREE.DoubleSide });
                //Load the background texture
                //backgroundtexture = THREE.ImageUtils.loadTexture('1.png');
                backgroundtexture = new THREE.Texture(videoImage);
                backgroundMesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2, 0), new THREE.MeshBasicMaterial({ map: videoTexture }));
                backgroundMesh.material.depthTest = false;
                backgroundMesh.material.depthWrite = false;
                // Create Background scene
                backgroundScene = new THREE.Scene();
                backgroundCamera = new THREE.Camera();
                backgroundScene.add(backgroundCamera);
                backgroundScene.add(backgroundMesh);
                // Renderer
                var container = document.body;
                renderer = new THREE.WebGLRenderer();
                renderer.antialias = true;
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setClearColor(0x222222);
                renderer.localClippingEnabled = true;
                window.addEventListener('resize', onWindowResize, false);
                container.appendChild(renderer.domElement);
                // Stats
                stats = new Stats();
                container.appendChild(stats.dom);
                // Load Files selected by the user
                group = new THREE.Object3D();
                fileElem = document.getElementById("File");
                //for (var j = 0; j < fileElem.files.length; j++) {
                 //   meshes[j] = [];
                  //  }
                
                var loader = new THREE.STLLoader();
                
                fileElem.addEventListener('change', function (event) {
                    gui = new dat.GUI();
                    var i,
                        files = fileElem.files,
                        len = files.length;
                    var h;
                    
                    for (var j = 0; j < len; j++)
                    {
                        hide_obj[j] = " ";
                    }
                                        

                    var callback = function (geometry) {
                        var color = new THREE.Color(Math.random(), Math.random(), Math.random());
                        var material = new THREE.MeshPhongMaterial({ color, specular: 0x111111, shininess: 200 });
                        mesh = new THREE.Mesh(geometry, material);
                        mesh.position.set(0, 0, 0);
                        mesh.rotation.set(0, -Math.PI / 2, 0);
                        mesh.scale.set(0.05, 0.05, 0.05);
                        mesh.castShadow = true;
                        mesh.receiveShadow = true;
                        mesh.name = files[i].name;
                        mesh.id = files[i].name;
                        hide_obj[i]=files[i].name;
                        meshes[i] = mesh;
                        hiders.push(mesh);
                        comeOn.push(hide_obj.slice(i, i + 1));
                        group.add(mesh);
                        
                        
                        
                        //petit_a_petit.push(variable[i]);
                        
                        h = {

                            toggleObjects: true

                        }
                            
                        
                       
                        i++;
                        
                        if (i < len)  // put the next load in the callback
                        {
                            loader.load('examples/models/stl/ascii/' + files[i].name, callback);
                            console.log("mais est ce que ca fait mal ?" + i);
                            variable[i] = gui.add(h, 'toggleObjects').name(files[i].name).listen();
                            
                            variable[i].onChange(function (value) {
                                //console.log(hiders);
                                hiders[i].visible = value;
                            });
                        }
                        
                        //variable[0].onChange(function hide);
                        
                        
                    };
                    
                    i = 0;
                    
                    loader.load('examples/models/stl/ascii/' + files[i].name, callback);
                    h = {

                        toggleObjects: true

                    }
                    variable[i] = gui.add(h, 'toggleObjects').name(files[i].name).listen(); 
                        
                    variable[i].onChange(function (value) {
                        console.log(hiders);
                        hiders[0].visible = value;
                    });
                    
                   }, false);

                
               scene.add(group);
               
                //GUI
               
                
               
                
                /*mode = {
                    visible: true

                };

                */
                

                // call to raycaster
                window.addEventListener('mousemove', onMouseMove, false);
                window.requestAnimationFrame(render);
                raycaster = new THREE.Raycaster();
                mouse = new THREE.Vector2();
                function onMouseMove(event) {
                    mouse.x = (event.clientX / innerWidth) * 2 - 1;
                    mouse.y = -(event.clientY / innerHeight) * 2 + 1;
                }
                // Controls
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.target.set(0, 1, 0);
                controls.update();
                // Start
                startTime = Date.now();
                time = 0;
            } //end init

                        
            function render() {
                // update the picking ray with the camera and mouse position
                raycaster.setFromCamera(mouse, camera);
                // calculate objects intersecting the picking ray
                var intersects = raycaster.intersectObjects(group.children);
                for (var i = 0; i < intersects.length; i++) {
                    intersects[i].object.material.color.set(0xff0000);

                }
                renderer.render(scene, camera);
            }
            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
            function update() {
                controls.update();
                stats.update();
            }
            function animate() {
                requestAnimationFrame(animate);
                if (video.readyState === video.HAVE_ENOUGH_DATA) {
                    videoImageContext.drawImage(video, 0, 0, videoImage.width, videoImage.height);
                    if (videoTexture) {
                        videoTexture.needsUpdate = true;
                    }
                }
                renderer.autoClear = false;
                renderer.clear();
                renderer.render(backgroundScene, backgroundCamera);
                stats.begin();
                renderer.render(scene, camera);
                stats.end();
                render();
                update();
            }
        </script>
    </div>

</body>

</html>