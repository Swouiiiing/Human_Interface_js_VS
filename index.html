<!DOCTYPE html>
<html lang="en">
<
<head>
    <title>Try Again</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=yes, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            position: absolute;
            top: 0px;
            margin: 0px 0px 0px 0px;
            z-index: 3;
            overflow: hidden;
        }

        #monitor {
            margin: 0px 0px 0px 0px;
            position: absolute;
            width: 100vw;
            height: 56.25vw;
            max-height: 100vw;
            max-width: 177.78vw;
            top: 0px;
            left: 0px;
            float: left;
            visibility: hidden;
            z-index: 1;
        }

        #videoImage {
            margin: 0px 0px 0px 0px;
            position: absolute;
            width: 100vw;
            height: 56.25vw;
            max-height: 100vw;
            max-width: 177.78vw;
            top: 0px;
            left: 0px;
            float: left;
            visibility: hidden;
            z-index: 5;
        }

        #File {
            position: absolute;
            top: 0px;
            left: 800px;
            z-index: 7;
        }
    </style>
</head>

<p id="errorMessage"></p>
<body>
    <video id="monitor" autoplay></video>
    <canvas id="videoImage" ></canvas>

    <form>
        <input type="file" id="File" onload="files_loaded(this.files)" multiple>
    </form>
    <div>
        <script>
            navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
            window.URL = window.URL || window.webkitURL;
            var camvideo = document.getElementById('monitor');
            if (!navigator.getUserMedia) {
                document.getElementById('errorMessage').innerHTML =
                    'Sorry. <code>navigator.getUserMedia()</code> is not available.';
            } else {
                navigator.getUserMedia({ video: true }, gotStream, noStream);
            }
            function gotStream(stream) {
                if (window.URL)
                { camvideo.src = window.URL.createObjectURL(stream); }
                else // Opera
                { camvideo.src = stream; }
                camvideo.onerror = function (e)
                { stream.stop(); };
                stream.onended = noStream;
            }
            function noStream(e) {
                var msg = 'No camera available.';
                if (e.code == 1)
                { msg = 'User denied access to use camera.'; }
                document.getElementById('errorMessage').textContent = msg;
            }
        </script>
        <script src="build/three.js"></script>
        <script src="examples/js/controls/OrbitControls.js"></script>
        <script src="examples/js/libs/stats.min.js"></script>
        <script src="examples/js/libs/dat.gui.min.js"></script>
        <script src="examples/js/loaders/STLLoader.js"></script>
        <script src="examples/js/renderers/Projector.js"></script>
        <script src="examples/js/Detector.js"></script>
        <script src="examples/js/libs/stats.min.js"></script>
        <script src="examples/js/THREEx.KeyboardState.js"></script>



        <script>
            var camera, scene, renderer;     //  Creation of the scene
            var width, height;
            var video, videoImage, videoImageContext, videoTexture, imageData, backgroundtexture, backgroundMesh, backgroundScene, backgroundCamera, stats, controls, mesh;  //creation of background

            //Variable for hide objects of the gui
            var group;
            var fileElem;
            var meshes = [];
            var gui;
            var variable = [];
            var hiders = [];
            var h;
            var Color = [];
            var textures = [];



            //loading textures in a txt file
            var text_data = [];
            var color_data = [];
            var colors_to_apply = [];

            //initialisation and looping the scene
            init();
            animate();
            function init() {

                camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.01, 800);
                camera.aspect = window.innerHeight / window.innerWidth;
                camera.position.set(-20, 10, 50);
                camera.lookAt(new THREE.Vector3(0, 0, 0, ));
                scene = new THREE.Scene();
                //Lights
                var light = new THREE.HemisphereLight(0xffffbb, 0x080820, 1);
                scene.add(light);
                scene.add(new THREE.AmbientLight(0x505050));
                // Video
                video = document.getElementById('monitor');
                videoImage = document.getElementById('videoImage');
                videoImageContext = videoImage.getContext('2d');
               


                // Background color if no video present
                videoImageContext.fillStyle = '#000000';
                videoImageContext.fillRect(0, 0, window.innerWidth, window.innerHeight);
                videoTexture = new THREE.Texture(videoImage);
                videoTexture.minFilter = THREE.LinearFilter;
                videoTexture.magFilter = THREE.LinearFilter;
                var movieMaterial = new THREE.MeshBasicMaterial({ map: videoTexture, overdraw: true, side: THREE.DoubleSide });
                //Load the background texture
               
                backgroundtexture = new THREE.Texture(videoImage);
                backgroundMesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2, 0), new THREE.MeshBasicMaterial({ map: videoTexture }));
                backgroundMesh.material.depthTest = false;
                backgroundMesh.material.depthWrite = false;
                // Create Background scene
                backgroundScene = new THREE.Scene();
                backgroundCamera = new THREE.Camera();
                backgroundScene.add(backgroundCamera);
                backgroundScene.add(backgroundMesh);
                // Renderer
                var container = document.body;
                renderer = new THREE.WebGLRenderer();
                renderer.antialias = true;
                renderer.setPixelRatio(window.devicePixelRatio);
                //camera.aspect = (video.clientHeight/video.clientWidth);
                
                
                renderer.setSize(window.innerWidth , window.innerHeight);
                renderer.setClearColor(0x222222);
                renderer.localClippingEnabled = true;
                
                window.addEventListener('resize', onWindowResize, false);
                container.appendChild(renderer.domElement);
                // Stats
                stats = new Stats();
                container.appendChild(stats.dom);
                // Load Files selected by the user
                group = new THREE.Object3D();
                fileElem = document.getElementById("File");

                //read a txt file contenaing color information
                function readTextFile(file) {
                    var rawFile = new XMLHttpRequest();
                    rawFile.open("GET", file);
                    rawFile.onreadystatechange = function () {
                        if (rawFile.readyState === 4) {
                            if (rawFile.status === 200 || rawFile.status == 0) {
                                var allText = rawFile.responseText;

                                //console.log(allText);
                                text_data = allText.split('\n');
                                for (var j = 0; j < text_data.length; j++) {
                                    color_data.push(text_data[j].split(" "));

                                }

                            }
                        }
                    }
                    rawFile.send(null);
                }
                readTextFile("http://localhost:54298/work/examples/textures/ApplicationTextures/test3.txt");

                //try to find a way to figure out how to get a fix path and not depend on the local host




                var loader = new THREE.STLLoader();
                var mamap = new THREE.TextureLoader();



                fileElem.addEventListener('change', function (event) {

                    var i,
                        files = fileElem.files,
                        len = files.length;

                    for (var j = 0; j < len; j++) {
                        var myMap = mamap.load('examples/textures/ApplicationTextures/' + files[j].name.split(".").reverse().pop() + '.jpg');
                        textures.push(myMap);
                    }

                    for (var z = 0; z < color_data.length; z++) {
                        for (var y = 1; y < color_data[z].length; y++) {
                            colors_to_apply.push(color_data[z][y]);

                        }

                    }


                    //fucbtion for load every files

                    var callback = function (geometry) {

                        //var material = new THREE.MeshPhongMaterial({ color, specular: 0x111111, shininess: 200, transparent: true }); //specular: 0x111111, shininess: 200,
                        // we get the rgb colors from the txt file
                        var coloration = new THREE.Color(colors_to_apply[v], colors_to_apply[v + 1], colors_to_apply[v + 2])
                        //we convert them in hexadecimal
                        var new_coloration = rgbToHex(coloration.r, coloration.g, coloration.b);
                        //we apply it to the material, the material is update at every call of the callback function
                        var material = new THREE.MeshPhongMaterial({ transparent: true, color: new_coloration });//map: textures[i] });




                        mesh = new THREE.Mesh(geometry, material);
                        mesh.position.set(0, 0, 0);
                        mesh.rotation.set(0, -Math.PI / 2, 0);
                        mesh.scale.set(0.05, 0.05, 0.05);
                        mesh.castShadow = true;
                        mesh.receiveShadow = true;
                        mesh.name = files[i].name;
                        meshes[i] = mesh;
                        hiders.push(mesh);
                        group.add(mesh);

                        i++;
                        v += 3;

                        if (i < len)  // put the next load in the callback
                        {
                            loader.load('examples/models/stl/ascii/' + files[i].name, callback);


                        }
                    };
                    v = 0
                    i = 0;

                    loader.load('examples/models/stl/ascii/' + files[i].name, callback);

                    //GUI

                    gui = new dat.GUI();
                    var folders = [];
                    var opacities = [];
                    //var textures = [];
                    for (var k = 0; k < len; k++) {
                        h = {
                            toggleObjects: true,
                            full_scene: true,
                            reset_scene: function () { reset_scene(); },
                            color: "#ff0000",
                            camera_locked: false,
                            opacity: 1
                        };

                        folders[k] = gui.addFolder(files[k].name.split(".").reverse().pop());
                        variable[k] = folders[k].add(h, 'toggleObjects').name('Visible').listen();
                        Color[k] = folders[k].addColor(h, 'color').name('color').listen();
                        opacities[k] = folders[k].add(h, 'opacity').min(0).max(1).step(0.01).name('Opacity').listen();

                    }

                    for (let l = 0; l < len; l++) {

                        variable[l].onChange(function (value) {

                            hiders[l].visible = value;
                        });
                    }

                    for (let m = 0; m < len; m++) {
                        Color[m].onChange(function (value)
                        { meshes[m].material.color.setHex(value.replace("#", "0x")); });
                    }

                    for (let n = 0; n < len; n++) {
                        opacities[n].onChange(function (value) {
                            meshes[n].material.opacity = value;
                        });
                    }

                    var hide_scene = gui.add(h, 'full_scene').name('Hide Scene').listen();
                    hide_scene.onChange(function (value) { scene.visible = value; });

                    gui.add(h, 'reset_scene').name('Reset');
                    function reset_scene() {
                        controls.reset();
                        for (let n = 0; n < len; n++) {
                            meshes[n].visible = true;
                        }

                    }

                    var lock_camera = gui.add(h, 'camera_locked').name('Lock Model').listen();
                    lock_camera.onChange(function (value) {
                        controls.enableZoom = !value;
                        controls.enableRotate = !value;
                        controls.enablePan = !value;
                    });

                }, false);


                scene.add(group);


                // Controls
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.target.set(0, 1, 0);
                controls.update();
                // Start
                startTime = Date.now();
                time = 0;
            } //end init
            function componentToHex(c) {
                var hex = parseFloat(c).toString(16);
                return hex.length == 1 ? "0" + hex : hex;
            }

            function rgbToHex(r, g, b) {
                return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
            }


            function render() {

                renderer.render(scene, camera);
            }

            function onWindowResize() {
                
                videoImage.width = videoImage.clientWidth;
                videoImage.height = videoImage.clientHeight;
                renderer.setViewport(0, 0, videoImage.clientWidth, videoImage.clientHeight);
                renderer.setSize(videoImage.clientWidth, videoImage.clientHeight);
                camera.aspect = videoImage.clientWidth / videoImage.clientHeight;
                camera.updateProjectionMatrix();
            }

            function update() {
                controls.update();
                stats.update();
            }

            function animate() {
                requestAnimationFrame(animate);
                if (video.readyState === video.HAVE_ENOUGH_DATA) {
                    
                    videoImageContext.drawImage(video, 0, 0, videoImage.width, videoImage.height);
                    if (videoTexture) {
                        videoTexture.needsUpdate = true;
                    }
                }
                renderer.autoClear = false;
                renderer.clear();
                renderer.render(backgroundScene, backgroundCamera);
                renderer.localClippingEnabled = false;
                stats.begin();
                renderer.render(scene, camera);
                stats.end();
                render();
                update();
            }



            //css modifications width="500" height="500"
        </script>
    </div>

</body>

</html>