<!DOCTYPE html>
<html lang="en">
<
<head>
    <title>Try Again</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=yes, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            position: absolute;
            top: 0px;
            margin: 0px 0px 0px 0px;
            z-index: 3;
            overflow: hidden;
        }

        #monitor {
            margin: 0px 0px 0px 0px;
            position: absolute;
            top: 0px;
            left: 0px;
            float: left;
            visibility: hidden;
            z-index: 1;
        }

        #videoImage {
            margin: 0px 0px 0px 0px;
            position: absolute;
            top: 0px;
            left: 0px;
            float: left;
            visibility: hidden;
            z-index: 5;
        }

        #File {
            position: absolute;
            top: 0px;
            left: 800px;
            z-index: 7;
        }
    </style>
</head>

<p id="errorMessage"></p>
<body>
    <video id="monitor" autoplay width="500" height="500"></video>
    <canvas id="videoImage" width="500" height="500"></canvas>

    <form>
        <input type="file" id="File" onload="files_loaded(this.files)" multiple>
    </form>
    <div>
        <script>
            navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
            window.URL = window.URL || window.webkitURL;
            var camvideo = document.getElementById('monitor');
            if (!navigator.getUserMedia) {
                document.getElementById('errorMessage').innerHTML =
                    'Sorry. <code>navigator.getUserMedia()</code> is not available.';
            } else {
                navigator.getUserMedia({ video: true }, gotStream, noStream);
            }
            function gotStream(stream) {
                if (window.URL)
                { camvideo.src = window.URL.createObjectURL(stream); }
                else // Opera
                { camvideo.src = stream; }
                camvideo.onerror = function (e)
                { stream.stop(); };
                stream.onended = noStream;
            }
            function noStream(e) {
                var msg = 'No camera available.';
                if (e.code == 1)
                { msg = 'User denied access to use camera.'; }
                document.getElementById('errorMessage').textContent = msg;
            }
        </script>
        <script src="build/three.js"></script>
        <script src="examples/js/controls/OrbitControls.js"></script>
        <script src="examples/js/libs/stats.min.js"></script>
        <script src="examples/js/libs/dat.gui.min.js"></script>
        <script src="examples/js/loaders/STLLoader.js"></script>
        <script src="examples/js/renderers/Projector.js"></script>
        <script src="examples/js/Detector.js"></script>
        <script src="examples/js/libs/stats.min.js"></script>
        <script src="examples/js/THREEx.KeyboardState.js"></script>
        
        

        <script>
            var camera, scene, renderer;     //  Creation of the scene
            var video, videoImage, videoImageContext, videoTexture, imageData, backgroundtexture, backgroundMesh, backgroundScene, backgroundCamera, stats, controls, mesh;  //creation of background
                        
            //Variable for hide objects of the gui
            var group;
            var fileElem;
            var meshes = [];
            var gui;
            var variable = [];
            var hiders = [];            
            var h;
            var Color = [];
            //initialisation and looping the scene
            
            init();
            animate();
            function init() {
                camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.01, 800);
                camera.position.set(-20, 10, 50);
                camera.lookAt(new THREE.Vector3(0, 0, 0, ));
                scene = new THREE.Scene();
                //Lights
                var light = new THREE.HemisphereLight(0xffffbb, 0x080820, 1);
                scene.add(light);
                scene.add(new THREE.AmbientLight(0x505050));
                // Video
                video = document.getElementById('monitor');
                videoImage = document.getElementById('videoImage');
                videoImageContext = videoImage.getContext('2d');
                //imageData = videoImageContext.getImageData();
                //var map_loader = new THREE.TextureLoader();
               // mappy = map_loader.load('examples/textures/planets/earth_atmos_2048.jpg');
                                                  
               
                // Background color if no video present
                videoImageContext.fillStyle = '#000000';
                videoImageContext.fillRect(0, 0, videoImage.innerWidth, videoImage.innerHeight);
                videoTexture = new THREE.Texture(videoImage);
                videoTexture.minFilter = THREE.LinearFilter;
                videoTexture.magFilter = THREE.LinearFilter;
                var movieMaterial = new THREE.MeshBasicMaterial({ map: videoTexture, overdraw: true, side: THREE.DoubleSide });
                //Load the background texture
                //backgroundtexture = THREE.ImageUtils.loadTexture('1.png');
                backgroundtexture = new THREE.Texture(videoImage);
                backgroundMesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2, 0), new THREE.MeshBasicMaterial({ map: videoTexture }));
                backgroundMesh.material.depthTest = false;
                backgroundMesh.material.depthWrite = false;
                // Create Background scene
                backgroundScene = new THREE.Scene();
                backgroundCamera = new THREE.Camera();
                backgroundScene.add(backgroundCamera);
                backgroundScene.add(backgroundMesh);
                // Renderer
                var container = document.body;
                renderer = new THREE.WebGLRenderer();
                renderer.antialias = true;
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setClearColor(0x222222);
                renderer.localClippingEnabled = true;
                window.addEventListener('resize', onWindowResize, false);
                container.appendChild(renderer.domElement);
                // Stats
                stats = new Stats();
                container.appendChild(stats.dom);
                // Load Files selected by the user
                group = new THREE.Object3D();
                fileElem = document.getElementById("File");
                

                var loader = new THREE.STLLoader();
                var mamap = new THREE.TextureLoader();

                fileElem.addEventListener('change', function (event) {

                    var i,
                        files = fileElem.files,
                        len = files.length;

                    var callback = function (geometry) {
                        //var color = new THREE.Color(Math.random(), Math.random(), Math.random());
                        //var color = new THREE.Color(imageData[0], imageData[1], imageData[2]);
                        //var material = new THREE.MeshPhongMaterial({ color, specular: 0x111111, shininess: 200, transparent: true }); //specular: 0x111111, shininess: 200,
                        
                        //mappy = map_loader.load('examples/textures/humanLiverTexture.png');
                        var material = new THREE.MeshPhongMaterial({transparent: true});
                        
                        mesh = new THREE.Mesh(geometry, material);
                        mesh.position.set(0, 0, 0);
                        mesh.rotation.set(0, -Math.PI / 2, 0);
                        mesh.scale.set(0.05, 0.05, 0.05);
                        mesh.castShadow = true;
                        mesh.receiveShadow = true;
                        mesh.name = files[i].name;
                        meshes[i] = mesh;
                        hiders.push(mesh);
                        group.add(mesh);
                        
                        i++;

                        if (i < len)  // put the next load in the callback
                        {
                            loader.load('examples/models/stl/ascii/' + files[i].name, callback);

                        }
                    };

                    i = 0;

                    loader.load('examples/models/stl/ascii/' + files[i].name, callback);

                    //GUI
                    
                    gui = new dat.GUI();
                    var folders = [];
                    var opacities = [];
                    var textures = [];
                    for (var k = 0; k < len; k++) {
                        h = {
                            toggleObjects: true,
                            full_scene: true,
                            reset_scene: function () { reset_scene(); },
                            color: "#ff0000",
                            camera_locked: false,
                            opacity: 1,
                            texture: ""

                        };
                        folders[k] = gui.addFolder(files[k].name.split(".").reverse().pop());
                        variable[k] = folders[k].add(h, 'toggleObjects').name('Visible').listen();
                        Color[k] = folders[k].addColor(h, 'color').name('color').listen();
                        opacities[k] = folders[k].add(h, 'opacity').min(0).max(1).step(0.01).name('Opacity').listen();
                        textures[k] = folders[k].add(h,'texture',["liver","bone"]).name('Organe texture').listen();                        
                    }

                    for (let l = 0; l < len; l++) {

                        variable[l].onChange(function (value) {
                             
                            hiders[l].visible = value;
                        });

                    }
                    for (let m = 0; m < len; m++) {
                        Color[m].onChange(function (value)
                        { meshes[m].material.color.setHex(value.replace("#", "0x")); });
                    }

                    for (let n = 0; n < len; n++)
                    {
                        opacities[n].onChange(function (value)
                        {
                            meshes[n].material.opacity = value;                            
                        });
                    }

                    for (let o = 0; o < len; o++) {

                        textures[o].onChange(function (value) {
                            //var name = meshes[o].name.split(".").reverse().pop();
                            if (value == "bone")
                            {
                                //console.log(value + " " + meshes[o]);
                                var myMap = mamap.load('examples/textures/' + value + '.jpg');
                                meshes[o].material.map = myMap;
                                meshes[o].material.needsUpdate = true;
                                console.log(myMap);
                            }
                            else if (value == "liver")
                            { //console.log(value + " " + meshes[o]); 
                                var myMap = mamap.load('examples/textures/' + value + '.jpg');
                                meshes[o].material.map = myMap;
                                meshes[o].material.needsUpdate = true;
                                console.log(myMap);
                            }
                            else
                            { console.log(value + " " + meshes[o]); }
                        });
                    }

                    

                    var hide_scene = gui.add(h, 'full_scene').name('Hide Scene').listen();
                    hide_scene.onChange(function (value) { scene.visible = value; });

                    gui.add(h, 'reset_scene').name('Reset');
                    function reset_scene()
                    {
                        controls.reset();
                        for (let n = 0; n < len; n++)
                        {
                            meshes[n].visible = true;
                        }
                                               
                    }

                    var lock_camera = gui.add(h, 'camera_locked').name('Lock Model').listen();
                    lock_camera.onChange(function (value) {
                    controls.enableZoom = !value;
                    controls.enableRotate = !value;
                    controls.enablePan = !value;
                    });
                    
                }, false);

                
                scene.add(group);
                                
                
                // Controls
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.target.set(0, 1, 0);
                controls.update();
                // Start
                startTime = Date.now();
                time = 0;
            } //end init

           /* function updateTexture() {

                var mamap = new THREE.TextureLoader();

                var value = h.texture;
                
                if (value == "bone")
                {
                    console.log(value);
                    var myMap = mamap.load('examples/textures/' + value + '.jpg');
                    console.log(myMap);
                    mesh.material.map = myMap;
                    mesh.material.needsUpdate = true;
                    
                }
                if (value == "liver")
                { console.log(value);}
                
                
            }*/


            function render() {
               
                renderer.render(scene, camera);
            }

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }

            function update() {
                controls.update();
                stats.update();
            }

            function animate() {
                requestAnimationFrame(animate);
                if (video.readyState === video.HAVE_ENOUGH_DATA) {
                    videoImageContext.drawImage(video, 0, 0, videoImage.width, videoImage.height);
                    if (videoTexture) {
                        videoTexture.needsUpdate = true;
                    }
                }
                renderer.autoClear = false;
                renderer.clear();
                renderer.render(backgroundScene, backgroundCamera);
                stats.begin();
                renderer.render(scene, camera);
                stats.end();
                render();
                update();
            }
        </script>
    </div>

</body>

</html>